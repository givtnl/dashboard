{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewEncapsulation } from '@angular/core';\nimport { ViewChild } from '@angular/core';\nimport 'fullcalendar';\nimport 'fullcalendar/dist/locale/nl';\nimport 'fullcalendar/dist/locale/de';\nimport { moment } from 'fullcalendar';\nimport { tap } from 'rxjs/operators';\nlet AssignComponent = class AssignComponent {\n  constructor(translate, allocationService, loggingService, ts, datePipe, cd, apiService, userService, dataService) {\n    this.translate = translate;\n    this.allocationService = allocationService;\n    this.loggingService = loggingService;\n    this.ts = ts;\n    this.datePipe = datePipe;\n    this.cd = cd;\n    this.apiService = apiService;\n    this.dataService = dataService;\n    this.options = {};\n    this.allCollectTyping = false;\n    this.allocateWeekName = '';\n    this.SelectedTab = SelectedTab;\n    this.currentTab = SelectedTab.Collects;\n    this.openedMobileEventId = -1;\n    this.firstDay = 0;\n    this.isAssignInputFieldVisisble = false;\n    this.cardIsSingleDay = true;\n    this.csvFileName = '';\n    this.selectedCSV = false;\n    this.showCsvPopup = false;\n    this.csvError = true;\n    this.isLoading = false;\n    this.hasOpenAllocation = false;\n    this.selectedAllocationDates = [];\n    this.allocLoader = {\n      show: false\n    };\n    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    this.userService = userService;\n    document.onkeydown = function (evt) {\n      evt = evt || window.event;\n      if (this.isDialogOpen && evt.keyCode === 27) {\n        this.closeDialog();\n      }\n      if (evt.keyCode === 46 && evt.shiftKey && this.allowDelete) this.deleteAllEvents();\n      if (evt.keyCode === 13 && evt.shiftKey && this.allowSave) this.saveAllEvents();\n    }.bind(this);\n    this.userService.collectGroupChanged.subscribe(() => {\n      this.ngOnInit();\n    });\n  }\n  ngAfterViewInit() {\n    this.cd.detectChanges();\n  }\n  ngOnInit() {\n    let firstDayFromStorage = this.dataService.getData('FirstDayOfWeek');\n    this.firstDay = !isNaN(firstDayFromStorage) ? firstDayFromStorage : 0;\n    this.events = [];\n    this.headerConfig = {\n      left: 'prev,next today',\n      center: 'title',\n      right: 'agendaWeek,agendaDay'\n    };\n    this.options['viewRender'] = function (view, element) {\n      this.agendaView = view;\n      this.isMonthView = view['type'] === 'month';\n      // the calendar view assumes local date/time (no TimeZone info), \n      // so toISOString() returns something like \"2022-10-30T00:00:00.000Z\" which is incorrect (assumes no time zone = Zulu)\n      // To correct this, we need to chop off the Z or other TZ indicator\n      this.currentViewStart = this.localDateTimeWithoutTZToISOString(view.start['_d']);\n      this.currentViewEnd = this.localDateTimeWithoutTZToISOString(view.end['_d']);\n      this.events.length = 0;\n      this.cd.detectChanges();\n      this.checkAllocationsV2();\n    }.bind(this);\n    this.options['eventAfterRender'] = function (event, element, view) {\n      this.eventAfterRender(event, element, view);\n    }.bind(this);\n    this.options['eventRender'] = function (event, element, view) {\n      this.eventRender(this, event, element, view);\n    }.bind(this);\n    this.options['eventAfterAllRender'] = function (view) {\n      // this.filteredEvents();\n    }.bind(this);\n    this.options['contentHeight'] = 'auto';\n    this.options['eventClick'] = function (event, jsEvent, view) {\n      let fullcalendar = jQuery(this.calendar['el']['nativeElement'].children[0]);\n      fullcalendar.fullCalendar('unselect');\n      this.openBucket(event);\n      if (this.oldJsEvent !== undefined) {\n        this.oldJsEvent.target.style.boxShadow = '0px 0px 15px transparent';\n      }\n      jsEvent.target.style.boxShadow = '0px 0px 15px #2E2957';\n      this.oldJsEvent = jsEvent;\n      let start = event.start;\n      let end = event.end;\n      if (view.name === 'month') {\n        start.stripTime();\n        end.stripTime();\n      }\n    }.bind(this);\n    this.options['nowIndicator'] = false;\n    this.options['firstDay'] = this.firstDay;\n    this.options['slotDuration'] = '00:30:00';\n    this.options['timezone'] = 'local';\n    this.options['defaultView'] = 'agendaWeek';\n    this.options['locale'] = this.translate.currentLang;\n    this.options['eventDurationEditable'] = false;\n    this.options['eventStartEditable'] = false;\n    this.options['fixedWeekCount'] = false;\n    this.options['unselectAuto'] = false;\n    this.options['selectable'] = true;\n    this.options['scrollTime'] = '08:00:00';\n    this.options['select'] = function (start, end, jsEvent, view, resource) {\n      this.createBucketWithRange(start['_d'], end['_d']);\n    }.bind(this);\n    this.apiService.getData('Allocations/AllocationTags').then(data => {\n      this.usedTags = data;\n    });\n  }\n  localDateTimeWithoutTZToISOString(dtWithoutTZ) {\n    let dtstring = dtWithoutTZ.toISOString();\n    // chop off TimeZone indicator. We should get a \"Z\" only, but check to be a bit more robust for not-so-conforming browsers\n    dtstring = dtstring.slice(-1) == \"Z\" ? dtstring.slice(0, -1) : dtstring.slice(0, 19);\n    return this.datePipe.toISODateUTC(new Date(dtstring));\n  }\n  get allowSave() {\n    let retVal = false;\n    if (this.selectedCard.hasChangedDates) {\n      retVal = true;\n    } else {\n      for (const collect of this.selectedCard.Collects) {\n        if (collect.allocationName && collect.nameIsChanged) {\n          retVal = true;\n          break;\n        }\n      }\n    }\n    return retVal;\n  }\n  get allowDelete() {\n    let returnValue = false;\n    if (this.selectedCard && this.selectedCard.Collects && this.selectedCard.Collects.length > 0) {\n      this.selectedCard.Collects.forEach(collect => {\n        if (collect.allocationId !== 0 && collect.allocationId != undefined) {\n          returnValue = true;\n        }\n      });\n    }\n    return returnValue;\n  }\n  setCollectName(item, allocation) {\n    allocation.allocationName = item.replace(\"<span class='autocomplete'>\", '').replace('</span>', '');\n  }\n  createBucketWithRange(start, end) {\n    let bigEvent = new MyEvent();\n    bigEvent.start = new moment(start);\n    bigEvent.end = new moment(end);\n    let countOfTransactions = this.events.filter(tx => {\n      return new Date(tx.start) >= start && new Date(tx.end) <= end;\n    }).map(tx => tx.transactions.length).reduce((sum, amount) => sum + amount, 0);\n    if (countOfTransactions > 0) {\n      bigEvent.transactions = this.events.filter(tx => {\n        return new Date(tx.start) >= start && new Date(tx.end) <= end;\n      }).map(tx => tx.transactions).reduce((p, s) => p.concat(s));\n      this.openBucket(bigEvent);\n    } else {\n      this.openBucket(bigEvent);\n    }\n  }\n  openBucket(event) {\n    let bucketCard = new BucketCard();\n    bucketCard.dtBegin = event.start['_d'];\n    bucketCard.dtEnd = event.end['_d'];\n    this.selectedAllocationDates = [event.start, event.end];\n    bucketCard.Collects = [];\n    for (let i = 0; i < 3; i++) {\n      if (event.transactions != undefined && event.transactions.filter(tx => {\n        return tx.CollectId === String(i + 1);\n      }).length > 0) {\n        let bcr = new BucketCardRow();\n        bcr.allocationId = event.transactions.filter(tx => {\n          return tx.CollectId === String(i + 1);\n        })[0].AllocationId;\n        bcr.accountId = event.transactions.filter(tx => {\n          return tx.CollectId === String(i + 1);\n        })[0].AccountId;\n        bcr.transactions = event.transactions.filter(tx => {\n          return tx.CollectId === String(i + 1);\n        });\n        bcr.allocationName = bcr.transactions[0].AllocationName;\n        bcr._allocationName = bcr.allocationName;\n        bcr.allocated = bcr.allocationName !== null;\n        bcr.collectId = String(i + 1);\n        bucketCard.Collects.push(bcr);\n      } else {\n        const element = new BucketCardRow();\n        element.transactions = [];\n        let tx = this.events.filter(e => event.start < e.end && event.end >= e.start).map(f => f.transactions);\n        let name = '';\n        if (tx.length > 0) {\n          let alloc = tx.reduce((p, s) => p.concat(s)).filter(tx => tx.CollectId === String(i + 1));\n          name = alloc.length > 0 ? alloc[0].AllocationName : '';\n        }\n        element.allocationName = name;\n        element.allocated = false;\n        element.collectId = String(i + 1);\n        bucketCard.Collects.push(element);\n      }\n    }\n    bucketCard.Fixed = [];\n    let fixedTransactions = event.transactions != undefined ? event.transactions.filter(tx => {\n      return tx.CollectId === null;\n    }) : [];\n    let fixedNames = new Set(fixedTransactions.map(tx => tx.AllocationName));\n    fixedNames.forEach(name => {\n      let fixedRow = new BucketCardRow();\n      fixedRow.allocationName = name;\n      fixedRow.transactions = fixedTransactions.filter(tx => {\n        return tx.AllocationName === name;\n      });\n      bucketCard.Fixed.push(fixedRow);\n    });\n    this.cardIsSingleDay = this.showDate(bucketCard.dtBegin) === this.showDate(bucketCard.dtEnd);\n    this.selectedCard = bucketCard;\n    this.isDialogOpen = true;\n    this.openedMobileEventId = event.id;\n    if (this.selectedCard.Collects.length > 0) this.currentTab = SelectedTab.Collects;else if (this.selectedCard.Fixed.length > 0) {\n      this.currentTab = SelectedTab.Fixed;\n    }\n  }\n  renderBuckets(bucketCollection) {\n    this.events = [];\n    let buckets = [];\n    this.hasOpenAllocation = false;\n    for (let i = 0; i < bucketCollection.Allocated.length; i++) {\n      let bucket = new Bucket();\n      bucket.bucketType = BucketType.Allocated;\n      bucket.dtBegin = bucketCollection.Allocated[i].dtBegin;\n      bucket.dtEnd = bucketCollection.Allocated[i].dtEnd;\n      bucket.Transactions = bucketCollection.Allocated[i].Transactions;\n      let nonAllocated = bucketCollection.NonAllocated.filter(nonAllocation => {\n        return new Date(nonAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(nonAllocation.dtEnd) <= new Date(bucket.dtEnd);\n      });\n      //filter out currently used non allocs\n      bucketCollection.NonAllocated = bucketCollection.NonAllocated.filter(nonAllocation => {\n        return !(new Date(nonAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(nonAllocation.dtEnd) <= new Date(bucket.dtEnd));\n      });\n      if (nonAllocated.length > 0) bucket.bucketType = BucketType.AllocatedWithNonAllocated;\n      nonAllocated.forEach(b => {\n        bucket.Transactions = bucket.Transactions.concat(b.Transactions);\n      });\n      let fixed = bucketCollection.Fixed.filter(fixedAllocation => {\n        return new Date(fixedAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(fixedAllocation.dtEnd) <= new Date(bucket.dtEnd);\n      });\n      bucketCollection.Fixed = bucketCollection.Fixed.filter(fixedAllocation => {\n        return !(new Date(fixedAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(fixedAllocation.dtEnd) <= new Date(bucket.dtEnd));\n      });\n      fixed.forEach(f => {\n        bucket.Transactions = bucket.Transactions.concat(f.Transactions);\n      });\n      buckets.push(bucket);\n    }\n    for (let i = 0; i < bucketCollection.Fixed.length; i++) {\n      let bucket = new Bucket();\n      bucket.bucketType = BucketType.Fixed;\n      bucket.dtBegin = bucketCollection.Fixed[i].dtBegin;\n      bucket.dtEnd = bucketCollection.Fixed[i].dtEnd;\n      bucket.Transactions = bucketCollection.Fixed[i].Transactions;\n      let nonAllocated = bucketCollection.NonAllocated.filter(nonAllocation => {\n        return new Date(nonAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(nonAllocation.dtEnd) <= new Date(bucket.dtEnd);\n      });\n      //filter out currently used non allocs\n      bucketCollection.NonAllocated = bucketCollection.NonAllocated.filter(nonAllocation => {\n        return !(new Date(nonAllocation.dtBegin) >= new Date(bucket.dtBegin) && new Date(nonAllocation.dtEnd) <= new Date(bucket.dtEnd));\n      });\n      if (nonAllocated.length > 0) bucket.bucketType = BucketType.AllocatedWithNonAllocated;\n      nonAllocated.forEach(b => {\n        bucket.Transactions = bucket.Transactions.concat(b.Transactions);\n      });\n      buckets.push(bucket);\n    }\n    //render overgebleven non allocs\n    for (let i = 0; i < bucketCollection.NonAllocated.length; i++) {\n      let bucket = new Bucket();\n      bucket.bucketType = BucketType.NonAllocated;\n      bucket.dtBegin = bucketCollection.NonAllocated[i].dtBegin;\n      bucket.dtEnd = bucketCollection.NonAllocated[i].dtEnd;\n      bucket.Transactions = bucketCollection.NonAllocated[i].Transactions;\n      buckets.push(bucket);\n    }\n    for (let i = 0; i < buckets.length; i++) {\n      let event = new MyEvent();\n      event.id = i;\n      event.start = new moment(new Date(buckets[i].dtBegin));\n      event.end = new moment(new Date(buckets[i].dtEnd));\n      event.transactions = buckets[i].Transactions;\n      switch (buckets[i].bucketType) {\n        case BucketType.Allocated:\n          event.className = 'allocation';\n          this.hasOpenAllocation = false;\n          break;\n        case BucketType.AllocatedWithNonAllocated:\n          event.className = 'allocation-mixed';\n          this.hasOpenAllocation = true;\n          break;\n        case BucketType.NonAllocated:\n          this.hasOpenAllocation = true;\n          event.className = 'money';\n          break;\n        case BucketType.Fixed:\n          this.hasOpenAllocation = false;\n          event.className = 'allocation';\n          break;\n      }\n      this.events.push(event);\n    }\n  }\n  checkAllocationsV2() {\n    return new Promise((resolve, reject) => {\n      let apiUrl = 'v2/CollectGroup/Buckets';\n      if (this.currentViewStart !== null && this.currentViewEnd !== null) {\n        apiUrl += '?dtBegin=' + this.currentViewStart + '&dtEnd=' + this.currentViewEnd;\n      }\n      this.isLoading = true;\n      this.apiService.getData(apiUrl).then(resp => {\n        this.isLoading = false;\n        if (resp === undefined) return;\n        let bucketCollection = resp;\n        this.renderBuckets(bucketCollection);\n        this.cd.detectChanges();\n        resolve();\n      }).catch(r => {\n        reject();\n      });\n    });\n  }\n  prevPeriod() {\n    this.openedMobileEventId = -1;\n    this.selectedCard = null;\n    this.isDialogOpen = false;\n    let nativeElement = jQuery(this.calendar['el']['nativeElement'].children[0]);\n    nativeElement.fullCalendar('prev');\n  }\n  nextPeriod() {\n    this.openedMobileEventId = -1;\n    this.selectedCard = null;\n    this.isDialogOpen = false;\n    let nativeElement = jQuery(this.calendar['el']['nativeElement'].children[0]);\n    nativeElement.fullCalendar('next');\n  }\n  closeDialog() {\n    jQuery(this.calendar['el']['nativeElement'].children[0]).fullCalendar('unselect');\n    this.allocLoader['show'] = false;\n    this.selectedCard = null;\n    this.selectedAllocationDates = null;\n    if (!this.selectedCSV) {\n      this.isDialogOpen = false;\n    }\n    if (this.oldJsEvent !== undefined) {\n      this.oldJsEvent.target.style.boxShadow = '0px 0px 15px transparent';\n    }\n  }\n  filterTags(typed) {\n    this.filteredUsedTags = [];\n    let regex = new RegExp(typed, 'i');\n    this.usedTags.forEach(function (value) {\n      if (value.search(regex) !== -1 && this.filteredUsedTags.length < 10 && value.trim() !== '') {\n        let hlight = \"<span class='autocomplete'>\" + value.match(regex)[0] + '</span>';\n        this.filteredUsedTags.push(value.replace(regex, hlight));\n      }\n    }, this);\n  }\n  deleteAllEvents() {\n    this.allocLoader['show'] = true;\n    const toDeleteItems = Array.from(new Set(this.selectedCard.Collects.map(t => t.transactions).map(r => r.map(u => u.AllocationId).filter(f => f !== 0)).reduce((a, b) => a.concat(b))));\n    this.allocationService.deleteAllocations(this.userService.CurrentCollectGroup.GUID, toDeleteItems).subscribe(x => {\n      this.reloadEvents();\n      this.closeDialog();\n    }).add(() => this.allocLoader['show'] = false);\n  }\n  saveAllEvents() {\n    if (!this.selectedCard || !this.selectedCard.Collects || this.selectedCard.Collects.length === 0) return;\n    this.allocLoader['show'] = true;\n    return new Promise((resolve, reject) => {\n      let dataAllocations = [];\n      this.selectedCard.Collects.forEach(collect => {\n        if (collect.allocationName === null || collect.allocationName === undefined || collect.allocationName === '') {\n          reject();\n          return;\n        } else {\n          dataAllocations.push({\n            Name: collect.allocationName,\n            dtBegin: this.selectedCard.dtBegin.toISOString(),\n            dtEnd: this.selectedCard.dtEnd.toISOString(),\n            CollectId: collect.collectId.trim(),\n            AccountId: collect.accountId\n          });\n        }\n      });\n      if (dataAllocations.length > 0) {\n        //GIVTPRJ-28286\n        this.apiService.postData('v2/Allocations/Allocation', dataAllocations).then(resp => {\n          this.reloadEvents();\n          resolve();\n        }).catch(err => {\n          reject();\n        });\n      } else reject();\n    });\n  }\n  reloadEvents() {\n    this.events.length = 0;\n    this.apiService.getData('Allocations/AllocationTags').then(data => {\n      this.usedTags = data;\n    });\n    this.checkAllocationsV2().then(a => {\n      let currentEvent = this.events.filter(e => {\n        return new Date(e.start).getTime() === new Date(this.selectedAllocationDates[0]).getTime() && new Date(e.end).getTime() === new Date(this.selectedAllocationDates[1]).getTime();\n      })[0];\n      if (currentEvent == undefined) {\n        this.createBucketWithRange(new Date(this.selectedAllocationDates[0]), new Date(this.selectedAllocationDates[1]));\n      } else {\n        this.createBucketWithRange(currentEvent.start, currentEvent.end);\n      }\n      this.allocLoader['show'] = false;\n    });\n  }\n  findEventIndexById(id) {\n    let index = -1;\n    for (let i = 0; i < this.events.length; i++) {\n      if (id === this.events[i].id) {\n        index = i;\n        break;\n      }\n    }\n    return index;\n  }\n  toggleError(setVisible, msg = '') {\n    this.errorShown = setVisible;\n    this.errorMessage = msg;\n  }\n  saveAllocation(title, collectId, startTime = null, endTime = null) {\n    return new Promise((resolve, reject) => {\n      if (title === '') {\n        resolve();\n        return;\n      }\n      let allocs = [];\n      let alloc = {};\n      alloc['Name'] = title;\n      alloc['dtBegin'] = startTime == null ? this.datePipe.toISODateUTC(new Date(this.startTime)) : this.datePipe.toISODateUTC(new Date(startTime));\n      alloc['dtEnd'] = endTime == null ? this.datePipe.toISODateUTC(new Date(this.endTime)) : this.datePipe.toISODateUTC(new Date(endTime));\n      alloc['CollectId'] = collectId.trim();\n      allocs.push(alloc);\n      this.apiService.postData('v2/allocations/allocation', allocs).then(resp => {\n        if (resp.status === 409) {\n          this.toggleError(true, 'Je zit met een overlapping');\n        }\n        if (!this.usedTags.some(function (element) {\n          if (element.toLowerCase() === title.toLowerCase()) return true;\n        })) {\n          this.usedTags.push(title);\n        }\n        resolve(resp); // <- this returns integer of added row id\n      }).catch(err => {\n        console.log(err);\n        reject();\n      });\n    });\n  }\n  changedTimePicker(e, changed) {\n    if (changed == this.selectedCard.dtBegin && this.selectedCard.dtBegin > this.selectedCard.dtEnd) {\n      this.selectedCard.dtEnd = moment(this.selectedCard.dtBegin).add(30, 'm').toDate();\n    } else if (this.selectedCard.dtEnd < this.selectedCard.dtBegin) {\n      this.selectedCard.dtBegin = moment(this.selectedCard.dtEnd).subtract(30, 'm').toDate();\n    }\n    //update selection\n    let fullcalendar = jQuery(this.calendar['el']['nativeElement'].children[0]);\n    fullcalendar.fullCalendar('select', this.selectedCard.dtBegin, this.selectedCard.dtEnd);\n    // check if dates changed and allow save\n    if (this.selectedAllocationDates[0] != this.selectedCard.dtBegin || this.selectedAllocationDates[1] != this.selectedCard.dtEnd) {\n      this.selectedCard.hasChangedDates = true;\n    }\n  }\n  showAllocActions(alloc) {\n    if (alloc.showActions) alloc.showActions = false;else if (!alloc.showActions && !alloc.showDetails) {\n      alloc.showDetails = true;\n      alloc.showActions = true;\n    } else alloc.showActions = true;\n  }\n  showAllocDetails(alloc) {\n    if (alloc.showDetails) {\n      alloc.showDetails = false;\n      if (alloc.showActions) alloc.showActions = false;\n    } else alloc.showDetails = true;\n  }\n  removeThisAllocation(id) {\n    if (!id || id <= 0) {\n      return;\n    }\n    this.allocationService.deleteAllocation(this.userService.CurrentCollectGroup.GUID, id).pipe(tap(response => this.checkAllocationsV2())).subscribe(x => {\n      const currentEvent = this.events.filter(e => {\n        return new Date(e.start).getTime() === new Date(this.selectedAllocationDates[0]).getTime() && new Date(e.end).getTime() === new Date(this.selectedAllocationDates[1]).getTime();\n      })[0];\n      if (currentEvent) {\n        this.openBucket(currentEvent);\n      }\n    });\n  }\n  updateThisAllocation(id) {\n    console.log('Updating allocation...');\n    return new Promise((resolve, reject) => {\n      if (id <= 0) {\n        resolve();\n        return;\n      }\n      this.apiService.deleteData('Allocations/Allocation/Update?Id=' + id).then(resp => {\n        if (resp.status !== 200) {\n          console.log('Response code: 200;');\n          return;\n        } else {\n          resolve(resp);\n          console.log(resp);\n        }\n      }).catch(err => {\n        console.log(err);\n        reject();\n      });\n    });\n  }\n  eventAfterRender(event, element, view) {}\n  eventRender(that, event, element, view) {\n    element[0].innerText = event.title;\n    element[0].addEventListener('mouseover', function (ev) {\n      let div = document.createElement('div');\n      div.innerHTML = '<span>' + this.ts.instant('ClickToViewMoreInformation') + '</span>';\n      div.className = 'balloon';\n      let offsets = ev.srcElement.getBoundingClientRect();\n      let top = offsets.top;\n      let left = offsets.left;\n      //div.style.top = top - div.offsetHeight +\"px\";\n      div.style.left = left + 'px';\n      document.getElementsByClassName('section-page')[0].appendChild(div);\n      div.style.top = top - div.offsetHeight - 17 + 'px';\n    }.bind(this));\n    element[0].addEventListener('mouseleave', function () {\n      let b = document.getElementsByClassName('balloon');\n      while (b.length > 0) {\n        b[0].remove();\n      }\n    }, true);\n    element[0].innerHTML = '';\n  }\n  onFocusOutOf(bucketRow) {\n    setTimeout(() => {\n      bucketRow.isTyping = false;\n      this.filteredUsedTags = [];\n    }, 200);\n  }\n  onFocusOutWeek() {\n    setTimeout(() => {\n      this.allCollectTyping = false;\n      this.filteredUsedTags = [];\n    }, 200);\n  }\n  displayValue(x) {\n    if (x === undefined) x = 0;\n    let currencySymbol = this.userService.currencySymbol;\n    if (!navigator.language.includes('en')) currencySymbol += ' ';\n    return currencySymbol + (this.isSafari ? parseFloat(x).toFixed(2) : x.toLocaleString(navigator.language, {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    }));\n  }\n  showDate(x) {\n    return x.toLocaleDateString(navigator.language, {\n      weekday: 'short',\n      day: 'numeric',\n      month: 'numeric',\n      year: 'numeric'\n    });\n  }\n  setWeekName(item) {\n    this.allocateWeekName = item.replace(\"<span class='autocomplete'>\", '').replace('</span>', '');\n  }\n  allocateWeek() {\n    let dataAllocations = [];\n    for (let i = 0; i < this.events.length; i++) {\n      let currentEvent = this.events[i];\n      let collectIdsToAdd = Array.from(new Set(currentEvent.transactions.filter(tx => {\n        return tx.AllocationId == 0 && tx.Fixed == false && tx.CollectId != null;\n      }).map(c => c.CollectId)));\n      collectIdsToAdd.forEach(collectId => {\n        dataAllocations.push({\n          name: this.allocateWeekName,\n          dtBegin: currentEvent.start.toISOString(),\n          dtEnd: currentEvent.end.toISOString(),\n          CollectId: collectId\n        });\n      });\n    }\n    this.allocateWeekName = '';\n    this.filteredUsedTags = [];\n    if (dataAllocations.length > 0) {\n      //GIVTPRJ-28286\n      this.apiService.postData('v2/Allocations/Allocation', dataAllocations).then(resp => {\n        this.reloadEvents();\n      }).catch(err => {\n        console.log(err);\n      });\n    }\n  }\n  allCollectNameChanging(event) {\n    this.filterTags(event);\n  }\n  closeCSVBox() {\n    this.selectedCSV = false;\n    if (this.selectedCard == null) this.isDialogOpen = false;\n  }\n  uploadCSV() {\n    if (this.addedAllocations.length > 0) {\n      for (let i = 0; i < this.addedAllocations.length; i++) {\n        let alloc = this.addedAllocations[i];\n        if (alloc.error) {\n          this.csvError = true;\n          this.showCsvPopup = true;\n          alloc.error = true;\n          this.ts.get('CsvError').subscribe(res => {\n            this.csvFileName = res;\n            alloc.errorMsg = res;\n          });\n          this.loggingService.info(`${alloc.errorMsg} on line: ${i + 1}`);\n          continue;\n        }\n      }\n      this.showCsvPopup = true;\n      this.ts.get('CsvSuccess').subscribe(res => {\n        this.csvFileName = \"'\" + this.csvFile.name + \"'\" + res;\n      });\n      this.isDialogOpen = true;\n      this.csvError = false;\n      for (let i = 0; i < this.addedAllocations.length; i++) {\n        let alloc = this.addedAllocations[i];\n        alloc.uploaded = false;\n        alloc.uploading = true;\n        if (!alloc.error) {\n          this.saveAllocation(alloc.name.trim(), alloc.collectId.trim(), alloc.dtBegin, alloc.dtEnd).then(() => {\n            alloc.uploaded = true;\n            alloc.uploading = false;\n            alloc.error = false;\n            this.checkAllocationsV2();\n          }).catch(() => {\n            alloc.uploading = false;\n            alloc.uploaded = false;\n            alloc.error = true;\n            if (!alloc.errorMsg) {\n              this.ts.get('OverlapError').subscribe(res => {\n                alloc.errorMsg = res;\n              });\n            }\n          });\n        }\n      }\n    }\n  }\n  downloadExampleCSV() {\n    if (navigator.language.includes('nl')) window.open('assets/Voorbeeld.csv');else window.open('assets/Example.csv');\n  }\n  startUpload() {\n    this.loggingService.info('User trying to upload CSV');\n    document.getElementById('inputfile').click();\n  }\n  fileChange(event) {\n    try {\n      this.selectedCSV = true;\n      this.addedAllocations = [];\n      let fileList = event.target.files;\n      if (fileList.length > 0) {\n        this.csvFile = fileList[0];\n        let reader = new FileReader();\n        reader.readAsText(this.csvFile);\n        reader.onload = e => {\n          let csv = reader.result;\n          let lineByLine = csv.split('\\n');\n          if (lineByLine.length == 1 || lineByLine.length == 2 && lineByLine[1].trim().length == 0) /* Only one line? Maybe \\n is not the newline character */\n            lineByLine = csv.split('\\r');\n          for (let i = 1; i < lineByLine.length; i++) {\n            let props = lineByLine[i].split(';');\n            if (props.length == 1) {\n              //First try splitting with comma's\n              props = lineByLine[i].split(',');\n              if (props.length == 1)\n                // skip empty lines\n                continue;\n            }\n            let alloc;\n            let name = props[2].trim();\n            let dtBegin = new Date(props[0]);\n            let dtEnd = new Date(props[1]);\n            let collectId = Number(props[3].trim());\n            if (this.isValidDate(dtBegin) && this.isValidDate(dtEnd) && dtEnd > dtBegin && name.length != 0 && [1, 2, 3].indexOf(collectId) != -1 && !isNaN(collectId)) {\n              alloc = {\n                name: name,\n                dtBegin: dtBegin,\n                dtEnd: dtEnd,\n                collectId: collectId.toString(),\n                dtBeginString: new Date(props[0]).toLocaleDateString(navigator.language, {\n                  day: 'numeric',\n                  year: 'numeric',\n                  month: 'numeric',\n                  hour: 'numeric',\n                  minute: 'numeric'\n                }),\n                dtEndString: new Date(props[1]).toLocaleDateString(navigator.language, {\n                  day: 'numeric',\n                  year: 'numeric',\n                  month: 'numeric',\n                  hour: 'numeric',\n                  minute: 'numeric'\n                })\n              };\n            } else {\n              alloc = {\n                name: name,\n                dtBegin: dtBegin,\n                dtEnd: dtEnd,\n                collectId: collectId.toString(),\n                dtBeginString: new Date(props[0]).toLocaleDateString(navigator.language, {\n                  day: 'numeric',\n                  year: 'numeric',\n                  month: 'numeric',\n                  hour: 'numeric',\n                  minute: 'numeric'\n                }),\n                dtEndString: new Date(props[1]).toLocaleDateString(navigator.language, {\n                  day: 'numeric',\n                  year: 'numeric',\n                  month: 'numeric',\n                  hour: 'numeric',\n                  minute: 'numeric'\n                }),\n                error: true\n              };\n            }\n            this.addedAllocations.push(alloc);\n          }\n          document.getElementById('inputfile').value = '';\n          this.uploadCSV();\n        };\n      }\n    } catch (error) {\n      this.loggingService.error(error);\n    }\n  }\n  isValidDate(d) {\n    return d instanceof Date && !isNaN(d.getTime());\n  }\n  closePopup() {\n    this.showCsvPopup = false;\n  }\n};\n__decorate([ViewChild('calendar')], AssignComponent.prototype, \"calendar\", void 0);\nAssignComponent = __decorate([Component({\n  selector: 'app-assign-collects',\n  templateUrl: '../html/assign.component.html',\n  styleUrls: ['../css/assign.component.css'],\n  encapsulation: ViewEncapsulation.None\n})], AssignComponent);\nexport { AssignComponent };\nexport var SelectedTab;\n(function (SelectedTab) {\n  SelectedTab[SelectedTab[\"Collects\"] = 0] = \"Collects\";\n  SelectedTab[SelectedTab[\"Fixed\"] = 1] = \"Fixed\";\n})(SelectedTab || (SelectedTab = {}));\nexport var ButtonState;\n(function (ButtonState) {\n  ButtonState[ButtonState[\"Enabled\"] = 0] = \"Enabled\";\n  ButtonState[ButtonState[\"isLoading\"] = 1] = \"isLoading\";\n  ButtonState[ButtonState[\"Saved\"] = 2] = \"Saved\";\n  ButtonState[ButtonState[\"Disabled\"] = 3] = \"Disabled\";\n})(ButtonState || (ButtonState = {}));\nexport class MyEvent {\n  constructor() {\n    this.allocated = true;\n  }\n}\nexport var BucketType;\n(function (BucketType) {\n  BucketType[BucketType[\"Allocated\"] = 0] = \"Allocated\";\n  BucketType[BucketType[\"NonAllocated\"] = 1] = \"NonAllocated\";\n  BucketType[BucketType[\"Fixed\"] = 2] = \"Fixed\";\n  BucketType[BucketType[\"AllocatedWithNonAllocated\"] = 3] = \"AllocatedWithNonAllocated\";\n})(BucketType || (BucketType = {}));\nexport class BucketCollection {}\nexport class Bucket {}\nexport class BucketTransaction {\n  constructor() {\n    this.AllocationName = null;\n  }\n}\nexport class BucketCard {}\nexport class BucketCardRow {\n  get nameIsChanged() {\n    return this._allocationName !== this.allocationName;\n  }\n  get numberOfTransactions() {\n    return this.transactions.map(tx => tx.Count).reduce((sum, amount) => sum + amount, 0);\n  }\n  get toProcess() {\n    return this.transactions.filter(tx => {\n      return tx.Status === 1 || tx.Status === 2;\n    }).map(tx => tx.Sum).reduce((sum, amount) => sum + amount, 0);\n  }\n  get processed() {\n    return this.transactions.filter(tx => {\n      return tx.Status === 3;\n    }).map(tx => tx.Sum).reduce((sum, amount) => sum + amount, 0);\n  }\n  get giftAidExtraSum() {\n    return this.transactions.filter(tx => {\n      return tx.Status < 4;\n    }).map(tx => tx.GiftAidSum).reduce((sum, amount) => sum + amount, 0) * 0.25;\n  }\n  get giftAidExtraCount() {\n    return this.transactions.filter(tx => {\n      return tx.Status < 4;\n    }).map(tx => tx.GiftAidCount).reduce((sum, amount) => sum + amount, 0);\n  }\n  get refusedByBank() {\n    return this.transactions.filter(tx => {\n      return tx.Status === 4;\n    }).map(tx => tx.Sum).reduce((sum, amount) => sum + amount, 0);\n  }\n  get cancelledByUser() {\n    return this.transactions.filter(tx => {\n      return tx.Status === 5;\n    }).map(tx => tx.Sum).reduce((sum, amount) => sum + amount, 0);\n  }\n  get total() {\n    return this.toProcess + this.processed + this.refusedByBank + this.cancelledByUser + this.giftAidExtraSum;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}