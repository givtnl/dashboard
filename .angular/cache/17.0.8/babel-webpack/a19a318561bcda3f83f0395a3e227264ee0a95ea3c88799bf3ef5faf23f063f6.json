{"ast":null,"code":"import { createPlugin } from '@fullcalendar/core/index.js';\nimport { buildDayTableModel, DayTableSlicer, TableRows, buildDayTableRenderRange, TableDateProfileGenerator } from '@fullcalendar/daygrid/internal.js';\nimport { DateComponent, memoize, getUniqueDomId, DayHeader, ViewContainer, formatIsoMonthStr, isPropsEqual, createDuration, intersectRanges, createFormatter, injectStyles } from '@fullcalendar/core/internal.js';\nimport { createElement, createRef } from '@fullcalendar/core/preact.js';\nclass SingleMonth extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.buildDayTableModel = memoize(buildDayTableModel);\n    this.slicer = new DayTableSlicer();\n    this.state = {\n      labelId: getUniqueDomId()\n    };\n  }\n  render() {\n    const {\n      props,\n      state,\n      context\n    } = this;\n    const {\n      dateProfile,\n      forPrint\n    } = props;\n    const {\n      options\n    } = context;\n    const dayTableModel = this.buildDayTableModel(dateProfile, context.dateProfileGenerator);\n    const slicedProps = this.slicer.sliceProps(props, dateProfile, options.nextDayThreshold, context, dayTableModel);\n    // ensure single-month has aspect ratio\n    const tableHeight = props.tableWidth != null ? props.tableWidth / options.aspectRatio : null;\n    const rowCnt = dayTableModel.cells.length;\n    const rowHeight = tableHeight != null ? tableHeight / rowCnt : null;\n    return createElement(\"div\", {\n      ref: props.elRef,\n      \"data-date\": props.isoDateStr,\n      className: \"fc-multimonth-month\",\n      style: {\n        width: props.width\n      },\n      role: \"grid\",\n      \"aria-labelledby\": state.labelId\n    }, createElement(\"div\", {\n      className: \"fc-multimonth-header\",\n      style: {\n        marginBottom: rowHeight\n      },\n      role: \"presentation\"\n    }, createElement(\"div\", {\n      className: \"fc-multimonth-title\",\n      id: state.labelId\n    }, context.dateEnv.format(props.dateProfile.currentRange.start, props.titleFormat)), createElement(\"table\", {\n      className: ['fc-multimonth-header-table', context.theme.getClass('table')].join(' '),\n      role: \"presentation\"\n    }, createElement(\"thead\", {\n      role: \"rowgroup\"\n    }, createElement(DayHeader, {\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: false\n    })))), createElement(\"div\", {\n      className: ['fc-multimonth-daygrid', 'fc-daygrid', 'fc-daygrid-body', !forPrint && 'fc-daygrid-body-balanced', forPrint && 'fc-daygrid-body-unbalanced', forPrint && 'fc-daygrid-body-natural'].join(' '),\n      style: {\n        marginTop: -rowHeight\n      }\n    }, createElement(\"table\", {\n      className: ['fc-multimonth-daygrid-table', context.theme.getClass('table')].join(' '),\n      style: {\n        height: forPrint ? '' : tableHeight\n      },\n      role: \"presentation\"\n    }, createElement(\"tbody\", {\n      role: \"rowgroup\"\n    }, createElement(TableRows, Object.assign({}, slicedProps, {\n      dateProfile: dateProfile,\n      cells: dayTableModel.cells,\n      eventSelection: props.eventSelection,\n      dayMaxEvents: !forPrint,\n      dayMaxEventRows: !forPrint,\n      showWeekNumbers: options.weekNumbers,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: forPrint\n    }))))));\n  }\n}\nclass MultiMonthView extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.splitDateProfileByMonth = memoize(splitDateProfileByMonth);\n    this.buildMonthFormat = memoize(buildMonthFormat);\n    this.scrollElRef = createRef();\n    this.firstMonthElRef = createRef();\n    this.needsScrollReset = false;\n    this.handleSizing = isForced => {\n      if (isForced) {\n        this.updateSize();\n      }\n    };\n  }\n  render() {\n    const {\n      context,\n      props,\n      state\n    } = this;\n    const {\n      options\n    } = context;\n    const {\n      clientWidth,\n      clientHeight\n    } = state;\n    const monthHPadding = state.monthHPadding || 0;\n    const colCount = Math.min(clientWidth != null ? Math.floor(clientWidth / (options.multiMonthMinWidth + monthHPadding)) : 1, options.multiMonthMaxColumns) || 1;\n    const monthWidthPct = 100 / colCount + '%';\n    const monthTableWidth = clientWidth == null ? null : clientWidth / colCount - monthHPadding;\n    const isLegitSingleCol = clientWidth != null && colCount === 1;\n    const monthDateProfiles = this.splitDateProfileByMonth(context.dateProfileGenerator, props.dateProfile, context.dateEnv, isLegitSingleCol ? false : options.fixedWeekCount, options.showNonCurrentDates);\n    const monthTitleFormat = this.buildMonthFormat(options.multiMonthTitleFormat, monthDateProfiles);\n    const rootClassNames = ['fc-multimonth', isLegitSingleCol ? 'fc-multimonth-singlecol' : 'fc-multimonth-multicol', monthTableWidth != null && monthTableWidth < 400 ? 'fc-multimonth-compact' : ''];\n    return createElement(ViewContainer, {\n      elRef: this.scrollElRef,\n      elClasses: rootClassNames,\n      viewSpec: context.viewSpec\n    }, monthDateProfiles.map((monthDateProfile, i) => {\n      const monthStr = formatIsoMonthStr(monthDateProfile.currentRange.start);\n      return createElement(SingleMonth, Object.assign({}, props, {\n        key: monthStr,\n        isoDateStr: monthStr,\n        elRef: i === 0 ? this.firstMonthElRef : undefined,\n        titleFormat: monthTitleFormat,\n        dateProfile: monthDateProfile,\n        width: monthWidthPct,\n        tableWidth: monthTableWidth,\n        clientWidth: clientWidth,\n        clientHeight: clientHeight\n      }));\n    }));\n  }\n  componentDidMount() {\n    this.updateSize();\n    this.context.addResizeHandler(this.handleSizing);\n    this.requestScrollReset();\n  }\n  componentDidUpdate(prevProps) {\n    if (!isPropsEqual(prevProps, this.props)) {\n      // an external change?\n      this.handleSizing(false);\n    }\n    if (prevProps.dateProfile !== this.props.dateProfile) {\n      this.requestScrollReset();\n    } else {\n      this.flushScrollReset();\n    }\n  }\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing);\n  }\n  updateSize() {\n    const scrollEl = this.scrollElRef.current;\n    const firstMonthEl = this.firstMonthElRef.current;\n    if (scrollEl) {\n      this.setState({\n        clientWidth: scrollEl.clientWidth,\n        clientHeight: scrollEl.clientHeight\n      });\n    }\n    if (firstMonthEl && scrollEl) {\n      if (this.state.monthHPadding == null) {\n        // always remember initial non-zero value\n        this.setState({\n          monthHPadding: scrollEl.clientWidth -\n          // go within padding\n          firstMonthEl.firstChild.offsetWidth\n        });\n      }\n    }\n  }\n  requestScrollReset() {\n    this.needsScrollReset = true;\n    this.flushScrollReset();\n  }\n  flushScrollReset() {\n    if (this.needsScrollReset && this.state.monthHPadding != null // indicates sizing already happened\n    ) {\n      const {\n        currentDate\n      } = this.props.dateProfile;\n      const scrollEl = this.scrollElRef.current;\n      const monthEl = scrollEl.querySelector(`[data-date=\"${formatIsoMonthStr(currentDate)}\"]`);\n      scrollEl.scrollTop = monthEl.getBoundingClientRect().top - this.firstMonthElRef.current.getBoundingClientRect().top;\n      this.needsScrollReset = false;\n    }\n  }\n  // workaround for when queued setState render (w/ clientWidth) gets cancelled because\n  // subsequent update and shouldComponentUpdate says not to render :(\n  shouldComponentUpdate() {\n    return true;\n  }\n}\n// date profile\n// -------------------------------------------------------------------------------------------------\nconst oneMonthDuration = createDuration(1, 'month');\nfunction splitDateProfileByMonth(dateProfileGenerator, dateProfile, dateEnv, fixedWeekCount, showNonCurrentDates) {\n  const {\n    start,\n    end\n  } = dateProfile.currentRange;\n  let monthStart = start;\n  const monthDateProfiles = [];\n  while (monthStart.valueOf() < end.valueOf()) {\n    const monthEnd = dateEnv.add(monthStart, oneMonthDuration);\n    const currentRange = {\n      // yuck\n      start: dateProfileGenerator.skipHiddenDays(monthStart),\n      end: dateProfileGenerator.skipHiddenDays(monthEnd, -1, true)\n    };\n    let renderRange = buildDayTableRenderRange({\n      currentRange,\n      snapToWeek: true,\n      fixedWeekCount,\n      dateEnv\n    });\n    renderRange = {\n      // yuck\n      start: dateProfileGenerator.skipHiddenDays(renderRange.start),\n      end: dateProfileGenerator.skipHiddenDays(renderRange.end, -1, true)\n    };\n    const activeRange = dateProfile.activeRange ? intersectRanges(dateProfile.activeRange, showNonCurrentDates ? renderRange : currentRange) : null;\n    monthDateProfiles.push({\n      currentDate: dateProfile.currentDate,\n      isValid: dateProfile.isValid,\n      validRange: dateProfile.validRange,\n      renderRange,\n      activeRange,\n      currentRange,\n      currentRangeUnit: 'month',\n      isRangeAllDay: true,\n      dateIncrement: dateProfile.dateIncrement,\n      slotMinTime: dateProfile.slotMaxTime,\n      slotMaxTime: dateProfile.slotMinTime\n    });\n    monthStart = monthEnd;\n  }\n  return monthDateProfiles;\n}\n// date formatting\n// -------------------------------------------------------------------------------------------------\nconst YEAR_MONTH_FORMATTER = createFormatter({\n  year: 'numeric',\n  month: 'long'\n});\nconst YEAR_FORMATTER = createFormatter({\n  month: 'long'\n});\nfunction buildMonthFormat(formatOverride, monthDateProfiles) {\n  return formatOverride || (monthDateProfiles[0].currentRange.start.getUTCFullYear() !== monthDateProfiles[monthDateProfiles.length - 1].currentRange.start.getUTCFullYear() ? YEAR_MONTH_FORMATTER : YEAR_FORMATTER);\n}\nconst OPTION_REFINERS = {\n  multiMonthTitleFormat: createFormatter,\n  multiMonthMaxColumns: Number,\n  multiMonthMinWidth: Number\n};\nvar css_248z = \".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}\";\ninjectStyles(css_248z);\nvar index = createPlugin({\n  name: '@fullcalendar/multimonth',\n  initialView: 'multiMonthYear',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    multiMonth: {\n      component: MultiMonthView,\n      dateProfileGeneratorClass: TableDateProfileGenerator,\n      multiMonthMinWidth: 350,\n      multiMonthMaxColumns: 3\n    },\n    multiMonthYear: {\n      type: 'multiMonth',\n      duration: {\n        years: 1\n      },\n      fixedWeekCount: true,\n      showNonCurrentDates: false\n    }\n  }\n});\nexport { index as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}