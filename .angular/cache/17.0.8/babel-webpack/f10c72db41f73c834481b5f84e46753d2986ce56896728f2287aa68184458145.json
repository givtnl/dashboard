{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { Validators } from '@angular/forms';\nimport { distinctUntilChanged, debounceTime, catchError, delay } from 'rxjs/operators';\nimport { Observable } from 'rxjs';\nimport { compareRows } from '../models/collect-scheduler/row-comparer.function';\nimport { GreaterThanDateValidator } from 'app/validators/allocation.validators';\nlet CollectsShedulerComponent = class CollectsShedulerComponent {\n  constructor(formBuilder, userService, service, datePipe, loggingService) {\n    this.formBuilder = formBuilder;\n    this.userService = userService;\n    this.service = service;\n    this.datePipe = datePipe;\n    this.loggingService = loggingService;\n    this.cacheKey = 'CollectSchedulerComponent';\n    this.loading = false;\n    this.bankAccounts = [];\n    this.currentCollectGroupAllocations = [];\n    this.pageSettings = {\n      currentPage: 1,\n      currentRowsPerPage: 10\n    };\n    this.userService.collectGroupChanged.subscribe(() => {\n      this.ngOnInit();\n    });\n  }\n  ngOnInit() {\n    this.service.getAllActiveAccounts(this.userService.CurrentCollectGroup.GUID).pipe(catchError(error => this.handleGenericError(error))).subscribe(response => {\n      this.bankAccounts = response;\n    });\n    this.getRows(this.pageSettings);\n  }\n  get collectsArray() {\n    return this.form.get('collects');\n  }\n  buildSingleForm(scheduler = null, copyId = false) {\n    const form = this.formBuilder.group({\n      id: [scheduler && copyId ? scheduler.Id : 0],\n      dtBegin: [scheduler && scheduler.dtBegin ? this.datePipe.transform(new Date(scheduler.dtBegin), 'yyyy-MM-ddTHH:mm') : null, [Validators.required]],\n      dtEnd: [scheduler && scheduler.dtEnd ? this.datePipe.transform(new Date(scheduler.dtEnd), 'yyyy-MM-ddTHH:mm') : null, [Validators.required]],\n      name: [scheduler ? scheduler.Name : null, [Validators.required, Validators.maxLength(256), Validators.minLength(1)]],\n      collectId: [scheduler ? scheduler.CollectId : 1, [Validators.required, Validators.min(1), Validators.max(3)]],\n      accountId: [scheduler && scheduler.AccountId ? scheduler.AccountId : this.bankAccounts.length > 1 && this.bankAccounts.find(a => a.Primary) ? this.bankAccounts.find(a => a.Primary).Id : null],\n      shouldNotShowError: !copyId\n    }, {\n      validator: GreaterThanDateValidator\n    });\n    form.valueChanges.pipe(debounceTime(1500)).pipe(distinctUntilChanged((oldValue, newValue) => compareRows(oldValue, newValue))).subscribe(x => this.upload(form));\n    return form;\n  }\n  addEmptyRow(index = 0) {\n    this.collectsArray.insert(index, this.buildSingleForm());\n  }\n  removeRow(index) {\n    const toDeleteFormGroup = this.collectsArray.at(index);\n    if (toDeleteFormGroup.value.id > 0) {\n      this.service.deleteAllocation(this.userService.CurrentCollectGroup.GUID, toDeleteFormGroup.value.id).pipe(catchError(error => this.handleGenericError(error))).subscribe(x => this.removeRowConfirm(index));\n    } else {\n      this.removeRowConfirm(index);\n    }\n  }\n  removeRowConfirm(index) {\n    this.collectsArray.removeAt(index);\n  }\n  copyRow(index) {\n    var row = this.collectsArray.at(index).value;\n    this.collectsArray.insert(index, this.buildSingleForm({\n      CollectId: null,\n      Name: row.name,\n      dtBegin: row.dtBegin,\n      dtEnd: row.dtEnd,\n      AccountId: row.accountId\n    }));\n  }\n  getRows(options) {\n    this.loading = true;\n    this.service.getAll(this.userService.CurrentCollectGroup.GUID, options.currentRowsPerPage, options.currentPage).pipe(delay(500)).pipe(catchError(error => this.handleGenericError(error))).subscribe(response => {\n      this.currentCollectGroupAllocations = response.Results;\n      this.currentTotalNumberOfPages = response.TotalNumberOfPages;\n      this.currentTotalCountOfRows = response.TotalCount;\n      this.form = this.formBuilder.group({\n        collects: this.formBuilder.array(this.currentCollectGroupAllocations ? this.currentCollectGroupAllocations.map(x => this.buildSingleForm(x, true)) : [])\n      });\n    }).add(() => this.loading = false);\n  }\n  formatAccount(accountId) {\n    const account = this.bankAccounts.find(x => x.Id === accountId);\n    var string = \"\";\n    if (account.AccountName) {\n      string += `${account.AccountName}`;\n      if (account.Iban) {\n        string += `(...${account.Iban.substr(account.Iban.length - 4)})`;\n      } else if (account.AccountNumber) {\n        string += `(...${account.AccountNumber.substr(account.AccountNumber.length - 4)})`;\n      }\n    } else {\n      if (account.Iban) {\n        string += `${account.Iban}`;\n      } else if (account.AccountNumber) {\n        string += `${account.SortCode}-${account.AccountNumber})`;\n      }\n    }\n    return string;\n  }\n  upload(row) {\n    if (row.invalid) {\n      return;\n    }\n    if (row.value.id && row.value.id > 0) {\n      let command = row.value;\n      command.dtBegin = new Date(command.dtBegin);\n      command.dtEnd = new Date(command.dtEnd);\n      // update existing allocation\n      this.service.updateAllocation(this.userService.CurrentCollectGroup.GUID, row.value.id, row.value).pipe(catchError(error => error.status === 409 || error.status === 422 || error.status === 500 ? this.handleConflict(error, row) : this.handleGenericError())).subscribe(x => this.loggingService.info(`Allocation with id '${row.value.id}' was updated for CollectGroup: ${this.userService.CurrentCollectGroup.Name}`));\n    } else {\n      // create a new allocation\n      let command = row.value;\n      command.dtBegin = new Date(command.dtBegin);\n      command.dtEnd = new Date(command.dtEnd);\n      this.service.createAllocation(this.userService.CurrentCollectGroup.GUID, row.value).pipe(catchError(error => error.status === 409 ? this.handleConflict(error, row) : this.handleGenericError())).subscribe(x => {\n        this.loggingService.info(`Allocation with id '${x.Id}' was created for CollectGroup: ${this.userService.CurrentCollectGroup.Name}`);\n        row.patchValue({\n          id: x.Id,\n          shouldNotShowError: false\n        });\n      });\n    }\n  }\n  handleConflict(error, form) {\n    if (form.value.shouldNotShowError) form.patchValue({\n      shouldNotShowError: false\n    });\n    form.setErrors({\n      overlap: true\n    });\n    return Observable.throw(error);\n  }\n  handleGenericError(error = null) {\n    console.log(error != null ? error : 'generic error');\n    return Observable.throw(error != null ? error : 'generic error');\n  }\n  hasErrors() {\n    return this.form && this.collectsArray && this.collectsArray.controls.some(formGroup => {\n      return !formGroup.value.shouldNotShowError && (formGroup.errors !== null || Object.keys(formGroup.controls).some(key => formGroup.get(key).errors !== null));\n    });\n  }\n};\nCollectsShedulerComponent = __decorate([Component({\n  selector: 'app-csveditor',\n  templateUrl: '../html/collects-scheduler.component.html',\n  styleUrls: ['../css/collects-scheduler.component.css']\n})], CollectsShedulerComponent);\nexport { CollectsShedulerComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}