{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewEncapsulation, ViewChild } from '@angular/core';\nimport { CalendarModule } from \"primeng/primeng\";\nimport { Collection } from \"../models/collection\";\nimport { visualCollection } from \"../models/visualCollection\";\nimport { BaseChartDirective } from \"ng2-charts\";\nimport { PaymentType } from \"../models/paymentType\";\nlet CollectsComponent = class CollectsComponent {\n  resetInfoButtonsPopovers(position) {\n    this.infoButtonShouldHavePopover = [false, false, false, false];\n  }\n  ngOnInit() {\n    this.checkAllocations();\n    this.fetchSavedCollects();\n    this.translate.get('ToProcessExplanation').subscribe(res => {\n      this.toProcessExplanation = this.userService.CurrentCollectGroup.PaymentType === PaymentType.BACS ? res.replace('SlimPay', 'Access PaySuite') : res;\n    });\n  }\n  constructor(apiService, translate, datePipe, dataService, userService) {\n    this.apiService = apiService;\n    this.translate = translate;\n    this.datePipe = datePipe;\n    this.dataService = dataService;\n    this.userService = userService;\n    this.isDataAvailable = false;\n    this.totalAmountsCombined = 0;\n    this.infoButtonShouldHavePopover = [false, false, false, false];\n    this.dateBegin = null;\n    this.dateEnd = null;\n    this.value = \"\";\n    this.isVisible = false;\n    this.savedCollects = [];\n    this.collectName = null;\n    this.collectId = null;\n    this.showCosts = false;\n    this.SearchButtonGreen = false;\n    this.activeRow = 1;\n    this.multipleCollects = false;\n    this.ShowLoadingAnimation = false;\n    this.terms = {\n      en: {\n        firstDayOfWeek: 0,\n        dayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n        dayNamesShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n        dayNamesMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n        monthNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n        monthNamesShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n      },\n      nl: {\n        firstDayOfWeek: 1,\n        closeText: 'Sluiten',\n        prevText: 'Terug',\n        nextText: 'Volgende',\n        currentText: 'Huidig',\n        monthNames: ['Januari', 'Februari', 'Maart', 'April', 'Mei', 'Juni', 'Juli', 'Augustus', 'September', 'Oktober', 'November', 'December'],\n        monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],\n        dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],\n        dayNamesShort: ['zo', 'ma', 'di', 'woe', 'do', 'vr', 'za'],\n        dayNamesMin: ['Zo', 'Ma', 'Di', 'Wo ', 'Do', 'Vr ', 'Za'],\n        weekHeader: 'Week',\n        firstDay: 1,\n        isRTL: false,\n        showMonthAfterYear: false,\n        yearSuffix: '',\n        timeOnlyTitle: 'Alleen tijd',\n        timeText: 'Tijd',\n        hourText: 'Uur',\n        minuteText: 'Minuut',\n        secondText: 'Seconde',\n        ampm: false,\n        month: 'Maand',\n        week: 'week',\n        day: 'Dag',\n        allDayText: 'Alle Dagen'\n      }\n    };\n    this.inputTitleLength = 1;\n    this.openAllocations = false;\n    this.pieChartLabels = [this.translate.instant(\"Text_Export\").toString(), 'Verwerkt', 'Geweigerd', \"Geannuleerd\"];\n    this.pieChartData = [0, 0, 0, 0];\n    this.pieChartType = 'pie';\n    this.chartColors = [{\n      backgroundColor: [\"#494874\", \"#41C98E\", \"#D43D4C\", \"#9B96B0\"]\n    }];\n    this.selectedIndex = -1;\n    this.pieChartOptions = {\n      responsive: true,\n      maintainAspectRatio: false,\n      legend: {\n        display: false\n      },\n      borderWidth: 0,\n      tooltips: {\n        filter: function (tooltipItem, data) {\n          return data.datasets[0].data[tooltipItem.index] != 0;\n        },\n        bodyFontColor: 'rgb(44,43,87)',\n        backgroundColor: 'rgb(255,255,255)',\n        callbacks: {\n          label: function (tooltipItem, data) {\n            let val = data.datasets[0].data[tooltipItem.index];\n            let label = data.labels[tooltipItem.index];\n            let amount = this.displayValue(val);\n            return label + \": \" + amount;\n          }.bind(this)\n        }\n      },\n      hover: {\n        onHover: (event, active) => {\n          if (active && active.length) {\n            let index = active[0]._index; //with this you get the index of the segment you hovered on\n            this.selectedIndex = index;\n          }\n        }\n      }\n    };\n    this.locale = navigator.language.includes('nl') ? 'nl-NL' : 'en-GB';\n    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    switch (this.translate.currentLang) {\n      case \"nl\":\n        this.locale = this.terms.nl;\n        break;\n      case \"en\":\n        this.locale = this.terms.en;\n        break;\n      default:\n        this.locale = this.terms.en;\n        break;\n    }\n    this.apiService = apiService;\n    this.text = \"dit zijn de collectes\";\n    this.calendarModule = new CalendarModule();\n    this.dateBeginTime = 5000;\n    this.maxDate = new Date();\n    this.dateBegin = new Date();\n    this.dateEnd = new Date();\n    this.dateBegin.setHours(6, 0, 0);\n    if (!!this.dataService.getData('collectDateBegin') && !!this.dataService.getData('collectDateEnd')) {\n      this.dateBegin = new Date(Number(this.dataService.getData('collectDateBegin')) * 1000);\n      this.dateEnd = new Date(Number(this.dataService.getData('collectDateEnd')) * 1000);\n    }\n    this.userService.collectGroupChanged.subscribe(() => {\n      this.ngOnInit();\n    });\n  }\n  checkAllocations() {\n    let apiUrl = 'v2/collectgroups/' + this.userService.CurrentCollectGroup.GUID + '/allocations/non-allocated/date-bounds';\n    this.apiService.getData(apiUrl).then(resp => {\n      if (resp) {\n        if (resp.length === 2) {\n          this.openAllocations = true;\n          let dtBegin = new Date(resp[0].dt_Confirmed);\n          let dtEnd = new Date(resp[1].dt_Confirmed);\n          this.openAllocationsMessage = this.translate.instant(\"MultipleOpenAllocationsMessage\");\n          this.openAllocationsMessage = this.openAllocationsMessage.replace(\"{0}\", dtBegin.toLocaleDateString(navigator.language, {\n            day: 'numeric',\n            month: 'numeric',\n            year: 'numeric'\n          }));\n          this.openAllocationsMessage = this.openAllocationsMessage.replace(\"{1}\", dtEnd.toLocaleDateString(navigator.language, {\n            day: 'numeric',\n            month: 'numeric',\n            year: 'numeric'\n          }));\n        } else if (resp.length === 1) {\n          this.openAllocations = true;\n          let dtBegin = new Date(resp[0].dt_Confirmed);\n          this.openAllocationsMessage = this.translate.instant(\"SingleOpenAllocationMessage\");\n          this.openAllocationsMessage = this.openAllocationsMessage.replace(\"{0}\", dtBegin.toLocaleDateString(navigator.language, {\n            day: 'numeric',\n            month: 'numeric',\n            year: 'numeric'\n          }));\n        }\n      }\n    });\n  }\n  selectRow(row) {\n    this.activeRow = row;\n    window.scrollBy({\n      top: 0,\n      left: 0,\n      behavior: 'smooth'\n    });\n  }\n  fetchSavedCollects() {\n    return this.apiService.getData(\"Collects/Collect\").then(resp => {\n      if (resp === undefined) {\n        this.savedCollects = [];\n        return;\n      }\n      this.savedCollects = resp;\n      for (let i in this.savedCollects) {\n        this.savedCollects[i].BeginDate = new Date(resp[i].BeginDate);\n        this.savedCollects[i].EndDate = new Date(resp[i].EndDate);\n        let start = this.savedCollects[i].BeginDate;\n        let end = this.savedCollects[i].EndDate;\n        this.savedCollects[i].BeginDateString = start.toLocaleDateString(navigator.language, {\n          day: \"numeric\",\n          year: 'numeric',\n          month: 'long'\n        }) + \" \" + this.datePipe.transform(start, 'shortTime');\n        this.savedCollects[i].EndDateString = end.toLocaleDateString(navigator.language, {\n          day: \"numeric\",\n          year: 'numeric',\n          month: 'long'\n        }) + \" \" + this.datePipe.transform(end, 'shortTime');\n        if (this.savedCollects[i].CollectId) {\n          this.savedCollects[i].MultipleCollects = true;\n        } else {\n          this.savedCollects[i].MultipleCollects = false;\n        }\n      }\n    });\n  }\n  selectCollect(collect) {\n    this.inputTitleLength = collect.Name.length - 2;\n    this.SearchButtonGreen = false;\n    this.collectId = null;\n    this.dateBegin = collect.BeginDate;\n    this.dateEnd = collect.EndDate;\n    this.multipleCollects = collect.MultipleCollects;\n    this.multipleCollectsId = collect.CollectId;\n    this.filterCollect(this.multipleCollectsId);\n    this.collectId = collect.Id;\n    this.collectName = collect.Name;\n    window.scrollTo(0, 0);\n  }\n  saveCollect() {\n    this.SearchButtonGreen = false;\n    let newCollect = new Collection();\n    newCollect.BeginDate = this.dateBegin;\n    newCollect.EndDate = this.dateEnd;\n    newCollect.Name = this.collectName;\n    if (this.multipleCollects) {\n      newCollect.CollectId = this.multipleCollectsId;\n    }\n    this.apiService.postData(\"Collects/Collect\", newCollect).then(resp => {\n      this.fetchSavedCollects().then(() => {\n        this.collectId = this.savedCollects[this.savedCollects.length - 1].Id;\n      });\n    }).catch(err => console.log(err));\n    setTimeout(this.fetchSavedCollects(), 1000);\n  }\n  deleteCollect(id) {\n    this.SearchButtonGreen = false;\n    if (id == undefined) return;\n    this.apiService.delete(\"Collects/Collect/\" + id).then(resp => {\n      this.isVisible = false;\n      this.fetchSavedCollects();\n      this.collectId = null;\n    }).catch(err => console.log(err));\n  }\n  fetchCollect() {\n    this.dataService.writeData(\"collectDateBegin\", Math.round(this.dateBegin.getTime() / 1000));\n    this.dataService.writeData(\"collectDateEnd\", Math.round(this.dateEnd.getTime() / 1000));\n    this.showCosts = false;\n    if (this.dateBegin !== null && this.dateEnd !== null) {\n      var dateBegin = this.datePipe.toISODateUTC(this.dateBegin);\n      var dateEnd = this.datePipe.toISODateUTC(this.dateEnd);\n      let params;\n      if (this.multipleCollects) {\n        params = \"DateBegin=\" + dateBegin + \"&DateEnd=\" + dateEnd + \"&CollectId=\" + this.multipleCollectsId;\n      } else {\n        params = \"DateBegin=\" + dateBegin + \"&DateEnd=\" + dateEnd + \"&Status=2\";\n      }\n      //.toLocaleDateString(navigator.language, { year: 'numeric', month: 'long'});\n      let beginTime = new Date(this.dateBegin.valueOf()).getTime();\n      let endTime = new Date(this.dateEnd.valueOf()).getTime();\n      this.sameDate = new Date(this.dateBeginRange).getDate() === new Date(this.dateEndRange).getDate();\n      this.dateBeginRange = new Object();\n      this.dateEndRange = new Object();\n      this.dateBeginRange.string = this.dateBegin.toLocaleDateString(navigator.language, {\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric'\n      }) + \" \" + this.datePipe.transform(beginTime, 'shortTime');\n      this.dateEndRange.string = this.dateEnd.toLocaleDateString(navigator.language, {\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric'\n      }) + \" \" + this.datePipe.transform(endTime, 'shortTime');\n      this.isVisible = true;\n    }\n  }\n  displayValue(x) {\n    let currencySymbol = this.userService.currencySymbol;\n    if (!navigator.language.includes('en')) currencySymbol += \" \";\n    return currencySymbol + (this.isSafari ? parseFloat(x).toFixed(2) : x.toLocaleString(navigator.language, {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    }));\n  }\n  onDateBeginChange(date) {\n    if (this.dateEnd && this.dateEnd.getTime() <= this.dateBegin.getTime()) {\n      this.dateEnd = new Date(this.dateBegin.getTime() + 0.5 * 60 * 60 * 1000);\n    } else if (!this.dateEnd) {\n      this.dateEnd = new Date(this.dateBegin.getTime() + 0.5 * 60 * 60 * 1000);\n    }\n  }\n  onDateEndChange(date) {\n    if (this.dateBegin && this.dateEnd.getTime() <= this.dateBegin.getTime()) {\n      this.dateBegin = new Date(this.dateEnd.getTime() - 0.5 * 60 * 60 * 1000);\n    } else if (!this.dateBegin) {\n      this.dateBegin = new Date(this.dateEnd.getTime() - 0.5 * 60 * 60 * 1000);\n    }\n  }\n  filterCollect(collectId) {\n    if (collectId == null || collectId == 0) {\n      this.multipleCollects = false;\n    } else {\n      this.multipleCollects = true;\n      this.multipleCollectsId = collectId;\n    }\n    this.fetchAllGivts();\n    this.fetchCollect();\n  }\n  fetchAllGivts() {\n    this.totalAmountsCombined = 0;\n    if (this.dateBegin !== null && this.dateEnd !== null) {\n      let baseParams;\n      if (this.multipleCollects) {\n        baseParams = \"&CollectId=\" + this.multipleCollectsId;\n      } else {\n        baseParams = \"\";\n      }\n      if (this.userService.CurrentCollectGroup) {\n        this.apiService.getData(\"v2/collectgroups/\" + this.userService.CurrentCollectGroup.GUID + \"/givts/view/search?dtBegin=\" + this.datePipe.toISODateUTC(this.dateBegin) + \"&dtEnd=\" + this.datePipe.toISODateUTC(this.dateEnd) + baseParams).then(serverResp => {\n          let resp = serverResp.reduce(function (rv, x) {\n            let el = rv.find(r => r && r.key === x.Status);\n            if (el) el.values.push(x);else rv.push({\n              key: x.Status,\n              values: [x]\n            });\n            return rv;\n          }, []);\n          //reset vars\n          this.infoToProcess = new visualCollection(0, 0);\n          this.infoProcessed = new visualCollection(0, 0);\n          this.infoCancelledByUser = new visualCollection(0, 0);\n          this.infoCancelledByBank = new visualCollection(0, 0);\n          this.pieChartData = [0, 0, 0, 0];\n          this.totalAmountsCombined = 0;\n          for (let i = 0; i < resp.length; i++) {\n            let currentResp = resp[i];\n            let count = currentResp.values.reduce(function (rv, x) {\n              rv += x.Count;\n              return rv;\n            }, 0);\n            let sum = currentResp.values.reduce(function (rv, x) {\n              rv += x.Sum;\n              return rv;\n            }, 0);\n            switch (currentResp.key) {\n              case 1:\n              case 2:\n                this.infoToProcess.numberOfUsers += count;\n                this.infoToProcess.totalAmount += sum;\n                break;\n              case 3:\n                this.infoProcessed.numberOfUsers += count;\n                this.infoProcessed.totalAmount += sum;\n                break;\n              case 4:\n                this.infoCancelledByBank.numberOfUsers += count;\n                this.infoCancelledByBank.totalAmount += sum;\n                break;\n              case 5:\n                this.infoCancelledByUser.numberOfUsers += count;\n                this.infoCancelledByUser.totalAmount += sum;\n                break;\n              default:\n                break;\n            }\n          }\n          this.pieChartLabels = [this.translate.instant(\"Processing\").toString(), this.translate.instant(\"Processed\"), this.translate.instant(\"CancelledByBank\"), this.translate.instant(\"CancelledByUser\")];\n          this.pieChartData = [this.infoToProcess.totalAmount, this.infoProcessed.totalAmount, this.infoCancelledByBank.totalAmount, this.infoCancelledByUser.totalAmount];\n          this.totalAmountsCombined = this.infoToProcess.totalAmount + this.infoProcessed.totalAmount + this.infoCancelledByBank.totalAmount + this.infoCancelledByUser.totalAmount;\n          //open the graph details when amount is available\n          if (this.totalAmountsCombined > 0) {\n            this.showCosts = true;\n          }\n          this.isDataAvailable = true;\n          if (this.chart != undefined) {\n            this.chart.chart.update();\n          }\n        });\n      }\n      this.isVisible = true;\n    }\n  }\n};\n__decorate([ViewChild(BaseChartDirective)], CollectsComponent.prototype, \"chart\", void 0);\nCollectsComponent = __decorate([Component({\n  selector: 'my-collects',\n  templateUrl: '../html/collects.component.html',\n  styleUrls: ['../css/collects.component.css'],\n  encapsulation: ViewEncapsulation.None\n})], CollectsComponent);\nexport { CollectsComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}